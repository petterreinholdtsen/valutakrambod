#!/usr/bin/python3

import configparser
import curses
import functools
import optparse
import time

from curses import wrapper
from os.path import expanduser
from sortedcontainers.sorteddict import SortedDict
from tornado import ioloop

import valutakrambod

class CursesViewer(object):
    def __init__(self, currencies = None):
        self.rates = SortedDict()
        self.lastrequest = {}
        self.errlog = []
        self.currencies = currencies
        configpath = expanduser('~/.config/btc-rates/config.ini')
        self.config = configparser.ConfigParser()
        self.config.read(configpath)
    def logerror(self, msg):
        now = time.time()
        self.errlog.append((now, msg))
    def data(self, service, pair, askprice, bidprice, stored, created):
        self.rates[(service.servicename(), pair)] = (service, askprice, bidprice, stored, created)
        self.drawdata()
        self.considerNewPeriod(service)

    def drawdata(self):
        self.stdscr.clear()
        maxy, maxx = self.stdscr.getmaxyx()
        line = 2
        now = time.time()
        s = "%15s %-6s %-11s %-11s %-5s  %4s %6s" % (
            "Name", "Pair", "Ask", "Bid", "Spr", "Ftcd", "Age",
            )
        self.stdscr.addstr( 1, 0, s)
        for entry in self.rates.keys():
            (service, askprice, bidprice, stored, created) = self.rates[entry]
            pair = entry[1]
            if created is not None:
                age = now - created
            else:
                age = float('nan')
            if askprice is not None and askprice != 0.0:
                spread = (1-bidprice/askprice)*100
            else:
                spread = float('nan')
            period = service.guessperiod()
            s = "%15s %s%s %11.4f %11.4f %5.1f%% %4d %6.f %6.f" % (
                entry[0],
                pair[0],
                pair[1],
                askprice,
                bidprice,
                spread,
                now - stored,
                age,
                period,
            )
            self.stdscr.addstr( line, 0, s)
            line = line + 1
        line = line + 1
        for when, error in self.errlog[-1::-1]:
            if line < maxy - 1:
                self.stdscr.addstr(line, 2, "%.1f %s" % (now - when, error[0:maxx-1]))
                line = line + 1
        self.stdscr.refresh()

    def newdata(self, service, pair):
        self.data(
            service,
            pair,
            service.rates[pair]['ask'],
            service.rates[pair]['bid'],
            service.rates[pair]['stored'],
            service.rates[pair]['when'],
        )
    def runRefresh(self, service):
        try:
            msg = "Updating %s" % service.servicename()
            self.stdscr.addstr( 0, 0, msg)
            self.stdscr.refresh()
            service.fetchRates(service.wantedpairs)
            self.stdscr.addstr( 0, 0, ' ' * len(msg))
            self.stdscr.refresh()
        except Exception as e:
            self.logerror("%s manual fetch: %s" % (service.servicename(), str(e)))
            # FIXME flag service as having problems?
    def considerNewPeriod(self, service):
        """Change update period, if it far from the current period and not too
short.
        """
        period = service.guessperiod()
        if period is not float('nan'):
            if period > 20 and \
               abs(service.periodic.callback_time/1000 - (period/2)) > 5:
              if False:
                self.logerror("Change %s period from %.1f (%1.f) to %.1f" % (
                    service.servicename(),
                    service.periodic.callback_time/1000,
                    abs(service.periodic.callback_time/1000 - (period/2)),
                    period/2,
                ))
                service.periodicUpdate(period / 2)
    def run(self, stdscr):
        self.stdscr = stdscr
        self.stdscr.clear()
        self.ioloop = ioloop.IOLoop.instance()
        collectors = []
        self.services = []
        for e in valutakrambod.service.knownServices():
            service = e(self.currencies)

            msg = "Enabling %s" % service.servicename()
            self.stdscr.addstr( 0, 0, msg)
            self.stdscr.refresh()

            service.confinit(self.config)
            self.services.append(service)
            service.subscribe(self.newdata)
            service.periodicUpdate(60)
            sock = service.websocket()
            if sock:
                collectors.append(sock)
                sock.connect()
            # Schedule initial updates, one second apart
            self.ioloop.call_later(len(self.services),
                                   functools.partial(self.runRefresh, service))

        try:
            self.ioloop.start()
        except KeyboardInterrupt:
            pass
        for c in collectors:
            c.close()

class dummyCurses(object):
    def clear(self):
        pass
    def getmaxyx(self):
        return (9999, 9999)
    def addstr(self, x, y, s):
        s = s.rstrip()
        if "" != s:
            print(s)
    def refresh(self):
        pass
def dummywrapper(f):
    return f(dummyCurses())    

def main():
    parser = optparse.OptionParser()
    parser.add_option('-c', action="store_true", dest='curses', default=False)
    opt, args = parser.parse_args()
    
    # The set of currencies we care about, only pairs in this set is
    # relevant.
    currencies = ['BTC', 'USD', 'EUR', 'NOK']
    c = CursesViewer(currencies)
    if opt.curses:
        wrapper(c.run)
    else:
        dummywrapper(c.run)

if __name__ == '__main__':
    main()
